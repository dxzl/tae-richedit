// I believe we can safely construe that this software may be released under
// the Free Software Foundation's GPL - I adopted TaeRichEdit for my project
// more than 15 years ago and have made significant changes in various
// places. Below is the original license. (Scott Swift 2015 dxzl@live.com)
//===========================================================================
// Copyright © 1999 Thin Air Enterprises and Robert Dunn.  All rights reserved.
// Free for non-commercial use.  Commercial use requires license agreement.
// See http://home.att.net/~robertdunn/Yacs.html for the most current version.
//===========================================================================
//---------------------------------------------------------------------------
// AdjLineBrks.cpp - implementation file for the TaeAdjustLineBreaks()
// function.
//---------------------------------------------------------------------------
#pragma inline
//#include <vcl.h>
#pragma hdrstop

#include "TaeAdjLineBrks.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
//---------------------------------------------------------------------------
// AdjustLineBreaks() adjusts all line breaks in the given source string
// to be true CR/LF sequences.  The function changes any CR characters
// not followed by a LF and any LF characters not preceded by a CR into
// CR/LF pairs.  It also converts LF/CR pairs to CR/LF pairs.  The LF/CR
// pair is common in Unix text files.
//
#pragma pack(push, 4)
int __fastcall TaeAdjustLineBreaks(unsigned char* Dest, unsigned char* Source)
{
asm {
    //  save source and destination index registers -- I removed this
    //  code because it was automatically generated by BCB4
    //  PUSH    ESI
    //  PUSH    EDI

    //  I replaced the following because I believed it to be dependent upon
    //  some arcane Delphi calling conventions that were not clearly
    //  preserved for BCB4.
    //  MOV     EDI,EAX
    //  MOV     ESI,EDX
    //  MOV     EDX,EAX

    // load the source and destination indexes with the passed values
    MOV     EDI, Dest
    MOV     ESI, Source

    // save the original starting position for the destination index
    // (apparently EDX is a scratch register).  we will use this later
    // to calculate how many bytes we stored in the destination buffer.
    MOV     EDX, EDI

    // clear the decrement flag (loads and stores move forwards through
    // the source and destination buffers)
    CLD

@@1:  // outer loop - load byte from source (ESI) and increment ESI.
    // this is the main loop entry point to fetch a byte from the
    // source buffer and evaluate it fully for improperly constructed
    // CR/LF code.
    LODSB

@@2:  // this is the entry point for evaluating a byte already fetched
    // from the source buffer and evaluating it for improperly
    // constructed CR/LF code...
    // test for zero byte (non-destructive)
    OR      AL,AL
    // jump to @@4 if so, continue otherwise
    JE      near @@4
    // do we have a newline (0x0a, '\n', aka LF)?
    CMP     AL,0AH
    // jump to @@3 if so, continue otherwise
    JE      near @@3
    // store the byte in destination (EDI) and increment EDI
    STOSB
    // was the byte a carriage return (0x0d, '\r', aka CR)?
    CMP     AL,0DH
    // jump back to outer loop if not, continue otherwise
    JNE     near @@1
    // have a CR (which we just stored); need to follow it with a LF
    // so load a LF, store it in destination, and load the next byte
    // (note that this increments both ESI and EDI)
    MOV     AL,0AH
    STOSB
    LODSB
    // is the new byte a LF?
    CMP     AL,0AH
    // if so, jump to the outer loop (i.e., eat the byte); otherwise,
    // jump to @@2 (which begins evaluating the byte to see if it is
    // the end of the string but also checks for LF -- could this be
    // be optimized?)
    JE      near @@1
    JMP     near @@2

@@3:  // we come here when we have an LF not preceded by a CR; we simply
    // load a CRLF into a two-byte register (EAX), store both bytes
    // with a single operation (which also increments EDI by two),
    // and unconditionally jump to the outer loop.
    // (note the reverse order that the byte values are loaded into EAX --
    // this is an architectural oddity of the xx80xx instruction
    // set -- the high order byte will be stored in memory following
    // the low order byte, so we end up with 0x0d followed by 0x0a
    // in memory)
    MOV     EAX,0A0DH
    STOSW
    JMP     near @@1

@@4:  // we come here when we have a zero byte in AL which indicates the
    // end of the buffer.  first, we store the byte...
    STOSB
    // subtract one from the destination index and store it in EAX
    LEA     EAX,[EDI-1]
    // subtract the index counter from EAX leaving the result in EAX
    SUB     EAX,EDX
    //  restore the saved register before exit -- I removed this code
    //  because it is automatically generated by BCB4
    //  POP     EDI
    //  POP     ESI
}
  // return the value from the EAX register (the count of bytes in
  // the destination buffer) -- note that _EAX is a pseudonym for
  // EAX above -- this ends up generating no actual code since the
  // return value for a function returning an int is normally
  // returned in the EAX register.  or, at least, I assume that is
  // the reason.  anyway, my BCB4 compiler generated no additional
  // code....
  return _EAX;
}
#pragma pack(pop)
//---------------------------------------------------------------------------
